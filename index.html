<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>System Intelligence Report</title>
  <style>
    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      background-color: #0d0d0d;
      color: #00ffcc;
      font-family: monospace;
      height: 100%;
    }

    .container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      padding: 20px;
    }

    .card {
      background-color: #111;
      border: 1px solid #00ffcc55;
      border-radius: 8px;
      padding: 30px;
      max-width: 800px;
      width: 100%;
      box-shadow: 0 0 20px rgba(0, 255, 200, 0.2);
      white-space: pre-wrap;
      overflow-wrap: break-word;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #00ffff;
      font-size: 24px;
    }

    #output {
      font-size: 14px;
      line-height: 1.6;
      min-height: 300px;
    }

    audio {
      position: fixed;
      bottom: 15px;
      left: 15px;
      width: 250px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>System Intelligence Report</h1>
      <pre id="output">Initializing...</pre>
    </div>
  </div>

  <audio autoplay loop>
    <source src="https://cdn.pixabay.com/download/audio/2022/02/20/audio_3b1e61a8e7.mp3?filename=relaxing-music-1233.mp3" type="audio/mpeg">
  </audio>

  <script>
    const output = document.getElementById("output");
    const sleep = ms => new Promise(r => setTimeout(r, ms));

    async function typeText(text, delay = 20) {
      for (const char of text) {
        output.textContent += char;
        await sleep(delay);
      }
      output.textContent += "\n";
    }

    async function typeLines(lines, delay = 100) {
      for (const line of lines) {
        await typeText(line);
        await sleep(delay);
      }
    }

    async function fetchIPData() {
      try {
        const res = await fetch("https://ip-api.com/json/");
        return res.ok ? res.json() : null;
      } catch {
        return null;
      }
    }

    async function checkVPN(ip) {
      try {
        const res = await fetch(`https://proxycheck.io/v2/${ip}?vpn=1&asn=1`);
        const data = await res.json();
        return data[ip]?.proxy === "yes" ? "YES" : "NO";
      } catch {
        return "UNKNOWN";
      }
    }

    function getCanvasHash() {
      try {
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        ctx.font = "14px Arial";
        ctx.fillText("Fingerprint!", 2, 2);
        return canvas.toDataURL().slice(-16);
      } catch {
        return "Unavailable";
      }
    }

    async function getAudioHash() {
      try {
        const ctx = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 44100, 44100);
        const osc = ctx.createOscillator();
        const comp = ctx.createDynamicsCompressor();
        osc.type = "triangle";
        osc.frequency.value = 10000;
        osc.connect(comp);
        comp.connect(ctx.destination);
        osc.start(0);
        const buffer = await ctx.startRendering();
        let sum = 0;
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) sum += Math.abs(data[i]);
        return sum.toString().slice(0, 10);
      } catch {
        return "Unavailable";
      }
    }

    function getWebGLInfo() {
      try {
        const canvas = document.createElement("canvas");
        const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        if (!gl) return { vendor: "Unavailable", renderer: "Unavailable" };
        const dbg = gl.getExtension("WEBGL_debug_renderer_info");
        return {
          vendor: dbg ? gl.getParameter(dbg.UNMASKED_VENDOR_WEBGL) : "Unavailable",
          renderer: dbg ? gl.getParameter(dbg.UNMASKED_RENDERER_WEBGL) : "Unavailable"
        };
      } catch {
        return { vendor: "Unavailable", renderer: "Unavailable" };
      }
    }

    async function getBatteryInfo() {
      if (navigator.getBattery) {
        try {
          const battery = await navigator.getBattery();
          return `${(battery.level * 100).toFixed(0)}% ${battery.charging ? "(Charging)" : "(Not Charging)"}`;
        } catch {
          return "Unavailable";
        }
      }
      return "Not Supported";
    }

    async function collectInfo() {
      const ipData = await fetchIPData();
      const vpnStatus = ipData ? await checkVPN(ipData.query) : "Unknown";

      const canvasHash = getCanvasHash();
      const audioHash = await getAudioHash();
      const webglInfo = getWebGLInfo();
      const batteryInfo = await getBatteryInfo();

      const lines = [];

      if (ipData) {
        lines.push(`IP Address: ${ipData.query}`);
        lines.push(`ISP: ${ipData.org}`);
        lines.push(`Country: ${ipData.country}`);
        lines.push(`Region: ${ipData.regionName}`);
        lines.push(`City: ${ipData.city}`);
        lines.push(`ZIP Code: ${ipData.zip}`);
        lines.push(`Coordinates: ${ipData.lat}, ${ipData.lon}`);
        lines.push(`Timezone: ${ipData.timezone}`);
        lines.push(`VPN/Proxy: ${vpnStatus}`);
      } else {
        lines.push("⚠️ Failed to retrieve IP/Geo info.");
      }

      lines.push("");
      lines.push("=== Device & Browser Info ===");
      lines.push(`User Agent: ${navigator.userAgent}`);
      lines.push(`Platform: ${navigator.platform}`);
      lines.push(`Language: ${navigator.language}`);
      lines.push(`Timezone: ${Intl.DateTimeFormat().resolvedOptions().timeZone}`);
      lines.push(`Screen Resolution: ${screen.width}x${screen.height}`);
      lines.push(`Color Depth: ${screen.colorDepth}`);
      lines.push(`CPU Threads: ${navigator.hardwareConcurrency ?? "Unknown"}`);
      lines.push(`RAM: ${navigator.deviceMemory ?? "Unknown"} GB`);
      lines.push(`Touch Support: ${'ontouchstart' in window ? "Yes" : "No"}`);
      lines.push(`Battery: ${batteryInfo}`);
      lines.push(`Online: ${navigator.onLine ? "Yes" : "No"}`);

      lines.push("");
      lines.push("=== Graphics Info ===");
      lines.push(`WebGL Vendor: ${webglInfo.vendor}`);
      lines.push(`WebGL Renderer: ${webglInfo.renderer}`);

      lines.push("");
      lines.push("=== Fingerprints ===");
      lines.push(`Canvas Hash: ${canvasHash}`);
      lines.push(`Audio Hash: ${audioHash}`);

      lines.push("");
      lines.push("=== Network Info ===");
      if (navigator.connection) {
        lines.push(`Connection Type: ${navigator.connection.effectiveType || "Unknown"}`);
        lines.push(`Downlink: ${navigator.connection.downlink ?? "Unknown"} Mbps`);
        lines.push(`RTT: ${navigator.connection.rtt ?? "Unknown"} ms`);
      } else {
        lines.push("Network Info: Not Supported");
      }

      lines.push("");
      lines.push("=== Browser Capabilities ===");
      lines.push(`Cookies Enabled: ${navigator.cookieEnabled ? "Yes" : "No"}`);
      lines.push(`LocalStorage Available: ${typeof localStorage !== "undefined" ? "Yes" : "No"}`);
      lines.push(`Clipboard API: ${"clipboard" in navigator ? "Yes" : "No"}`);
      lines.push(`Vibration API: ${"vibrate" in navigator ? "Yes" : "No"}`);

      return lines;
    }

    (async () => {
      output.textContent = "";
      const infoLines = await collectInfo();
      await typeLines(infoLines);
    })();
  </script>
</body>
</html>